## 프로세스 메모리 구조

### 프로세스 메모리 레이아웃
실행 파일을 열 때마다 운영체제는 새 프로세스를 만듭니다. 프로세스는 메모리에 로딩됩니다. 그리고 고유의 프로세스 식별자(PID)를 가집니다. 운영체제는 새 프로세스의 스폰과 로딩을 담당하는 유일한 개체입니다.

프로세스는 정상적으로 종료될 떄까지, 또는 SIGTERM, SIGINT, SIGKILL과 같은 종료 신호가 주어질 떄까지 계속 실행됩니다.
SIGTERM와 SIGINT 신호는 무시될 수 있지만, SIGKILL은 프로세스를 강제로 즉시 종료되도록 합니다.

+ SIGTERM 종료 신호입니다. 프로세스를 청소하도록 합니다.
+ SIGINT 인터럽트 신호입니다. Ctrl + C 키를 눌러 포그라운드 프로세스로 전달합니다.
+ SIGKILL 킬 신호입니다. 프로세스를 청소하지 않고 강제로 종료합니다.

프로세스를 생성할 때 OS는 프로세스를 위한 메모리를 가장 먼저 할당한 다음, 미리 정의된 메모리 레이아웃을 적용합니다.
이렇게 미리 정의된 메모리 레이아웃은 특히 유닉스 계열의 다른 운영체제에서도 거의 같습니다.

일반적으로 프로세스의 메모리 레이아웃은 여러 부분으로 분할됩니다. 각 부분은 세그먼트라고 부릅니다. 각 세그먼트는 정해진 작업을 수행하며 특정 자료형을 저장하는 메모리 영역입니다.

다음은 실행중인 프로세스의 메모리 레이아웃에 포함되는 목록입니다.
+ 초기화되지 않은 데이터 세그먼트 또는 BSS 세그먼트
+ 데이터 세그먼트
+ 텍스트 세그먼트, 코드 세그먼트
+ 스택
+ 힙

프로세스는 운영체제 내에서 실행 중인 개체입니다. 반면, 실행 가능한 목적 파일은 그저 파일에 불과합니다. 이 파일은 향후 프로세스를 스폰하는 토대가 되는 실행 가능한 목적 파일에서 직접 만듭니다. 다른 세그먼트는 프로세스가 로딩될 때, 프로그램이 실행되는 동안 동적으로 생성됩니다. 전자는 정적 메모리 레이아웃이며 후자는 동적 메모리 레이아웃이라고 합니다.

정적 메모리 레이아웃과 동적 메모리 레이아웃은 사전에 정의된 **세그먼트의 집합**입니다. 정적 메모리 레이아웃의 내용은 소스 코드를 컴파일할 때 컴파일러가 실행 가능한 목적 파일에 미리 작성합니다. 반면 동적 메모리 레이아웃의 내용은 프로그램의 명령어에 따라 작성됩니다. 프로그램 명령어는 변수와 배열에 메모리를 할당하며, 프로그램의 로직에 따라 변수와 배열을 수정합니다.

소스 코드나 컴파일된 목적 파일만 봐도 정적 메모리 레이아웃의 내용을 추측할 수 있습니다. 그러나 동적 메모리 레이아웃의 내용은 프로그램을 실행하지 않으면 결정되지 않으므로 쉽게 알 수 없습니다. 게다가 같은 실행 파일이라도 실행할 때마다 동적 메모리 레이아웃의 내용이 달라집니다. 즉 프로세스의 동적 내용은 해당 프로세스마다 다르므로 프로세스가 실행되는 동안 검사가 이루어져야 합니다.

### 정적 메모리 레이아웃 검사하기
정적 메모리 레이아웃을 검사하는 도구는 목적 파일에서 주로 작동합니다.
