## C가 객체지향이 아닌 이유
C는 객체지향이 아니지만, 이는 단순히 C언어가 오래되어서 그런 것은 아닙니다. C언어의 최신 표준은 C언어를 객체지향으로 만들려고 하지 않습니다. 인간은 객체지향적 방식으로 사고하지만 CPU는 절차지향적 기계 명령어를 실행합니다.
CPU는 명령어를 하나씩 실행할 뿐이고, 떄로는 메모리의 다른 주소에서 다른 명령어로 넘어가거나, 다른 명령어를 가져오거나 실행해야 합니다. 이는 C와 같은 절차지향적 프로그래밍 언어로 작성한 프로그램의 함수 호출과 꽤 비슷합니다.
C는 객체지향 언어가 될 수 없습니다. 객체지향과 절차지향 프로그래밍 사이를 가르는 장벽에 위치하기 때문입니다.

## 캡슐화
각각의 객체는 객체에 추가된 속성의 집합 및 기능의 집합입니다. 여기에서는 이 속성과 기능을 객체라는 개체에 넣는 작업을 설명하겠습니다. 이는 **캡슐화**라는 과정을 통해 수행합니다.
캡슐화란 객체를 나타내는 캡슐에 서로 연관된 것을 집어넣는다는 의미입니다. 객체는 속성의 집합 그리고 기능의 집합으로 만들어집니다. 속성과 기능은 둘 다 객체 캡슐로 캡슐화되어야 합니다.

### 속성캡슐화
서로 다른 변수를 묶어서 같은 객체 내에 그룹으로 두는 예제입니다.
```C
int pixel_p1_x = 56;
int pixel_p1_y = 34;
int pixel_p1_red = 123;
int pixel_p1_green = 37;
int pixel_p1_blue = 127;
...
```
이 예제는 암묵적 객체인 p1과 p2 아래에서 변수를 그루핑할 때 변수명을 어떻게 사용하는지 명확하게 보여줍니다.
암묵적이란, 개발자가 이 객체의 존재를 아는 유일한 사람이라는 뜻입니다. 프로그래밍 언어는 이 객체에 대해서 아무것도 모릅니다.
프로그래밍 언어는 위 코드에서 독립적인 것처럼 보이는 변수만을 이해합니다. 이는 변수의 이름을 지정할 수 있으므로 공식적인 캡슐화로 여겨지지 않을 정도로 저수준의 캡슐화일 것입니다. 변수 이름에 의한 캡슐화는 모든 프로그래밍 언어에서 가능하며 심지어 어셈블리어에서도 가능합니다. 필요한 것은 명시적 캡슐화를 제공하는 접근법입니다. 명시적이란 개발자와 프로그래밍 언어 둘 다 캡슐화, 캡슐의 존재를 안다는 의미입니다. 명시적 속성 캡슐화를 제공하지 않는 프로그래밍 언어는 사용하기 매우 어렵습니다.
C언어는 명시적 캡슐화를 제공합니다. 하지만 C는 명시적 행위 캡슐화를 제공하지는 않으니 이를 지원하려면 암묵적인 방식을 생각해야합니다. 또한 캡슐화와 같이 명시적인 기능을 항상 사용하는 편이 좋습니다. 명시적 기능은 상속이나 다형성 같은 다른 객체지향적 기능으로 확장될 수 있습니다.
이러한 명시적 기능은 프로그래밍 언어가 런타임이 아닌 컴파일을 할 때 관련 오류를 잡을 수 있도록 합니다.


```C
typedef struct {
	int x, y;
	int red, green, blue;
}pixel_t;

int main() {
	pixel_t p1, p2;
	
	p1.x = 56;
	p1.y = 34;
	p1.red = 123;
	p1.green = 37;
	p1.blue = 127;

	p2.x = 212;
	p2.y = 994;
	p2.red = 127;
	p2.green = 127;
	p2.blue = 0;
}
```

위 코드에서 주목할 사항이 몇 가지 있습니다.

+ 속성 캡슐화는 x, y, red, green, blue 속성을 새 자료형인 pixel_t로 넣을 떄 발생합니다.
+ 캡슐화는 언제나 새로운 자료형을 만듭니다. C에서는 속성 캡슐화로 새로운 자료형을 만듭니다. 실제로 이런 방식으로 명시적인 캡슐화를 수행합니다.
+ 새 자료형인 pixel_t는 클래스 혹은 객체 템플릿의 유일한 속성입니다. 아쉽게도 C에는 클래스에 대응하는 개념이 없습니다. 속성과 기능이 따로따로 존재하고 우리는 이 둘을 암묵적으로 코드에 연관시킵니다.
+ 템플릿에 기반한 객체를 생성했으며 이 템플릿은 객체가 생성될 때 미리 결정된 속성을 갖습니다. 구조체는 속성만을 저장할 뿐 기능은 저장하지 못합니다.
+ C및 다른 프로그래밍 언어에서 객체 내부의 속성에 접근할 때 점(.)을 사용하는 반면 포인터에 저장된 주소를 통해 간접적으로 구조체의 속성에 접근할 떄는 화살표(->)를 사용합니다. p1.x 혹은 p1이 포인터일 떄 p1->x라고 사용합니다. 속성 x가 p1안에 있다고 읽어야 합니다.
